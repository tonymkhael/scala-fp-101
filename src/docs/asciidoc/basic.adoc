:experimental: true
:stem: latexmath

== Functional Programming

=== Restricted definition

. No mutable varialbes
. No assignments
. No loops
. Or any other control structure

=== Wider definition

Functions are 1st class citizens of the language..

They can be:

. Produced (function as return type)
. Consumed (function as parameter)
. Composed (f1 o f2)

=== Languages

|===
|Language | Type

|Haskell
|Pure

|Pure lisp
|Pure

|Scala
|Hybrid

|F#
|Hybrid

|Clojure
|Hybrid

|...
|...

|===

=== Substitution model (Call by value)

Given sqr(x) = x * x , sumsqr(x,y) = sqr(x) + sqr(y) 

kbd:[->] sumsqr(3, 2+2)

kbd:[->] sumsqr(3, 4)

kbd:[->] sqr(3) + sqr(4)

kbd:[->] 3 * 3 + sqr(4)

kbd:[->] 9 + sqr(4)

kbd:[->] 9 + 4 * 4

kbd:[->] 9 + 16

kbd:[->] 25

=== Call by name

Given sqr(x) = x * x , sumsqr(x,y) = sqr(x) + sqr(y) 

kbd:[->] sumsqr(3, 2+2)

kbd:[->] sqr(3) + sqr(2 + 2)

kbd:[->] 3 * 3 + sqr(2 + 2)

kbd:[->] 9 + sqr(2 + 2)

kbd:[->] 9 + (2 + 2) * (2 + 2)

kbd:[->] 9 + 4 * (2 + 2)

kbd:[->] 9 + 4 * 4

kbd:[->] 9 + 16

kbd:[->] 25

=== CBV vs CBN (1)

. Both yield same result

.. If they only consist of pure functions (no side effects)
.. If both evaluations terminate (no infinite loops)

. CBV evaluates an argument only once

. CBN differs argument evaluation until it is used

. If CBV terminates, CBN terminates.

. The opposite is not true

=== CBV vs CBN (2)

first(x, y) = x , loop(x) = loop(x)

CBV: first(x, loop) kbd:[->] first(x, loop) kbd:[->] first(x, loop) kbd:[->] ...

CBN: first(x, loop) kbd:[->] x

def first(x: Int, y: => Int) = x

x is by value parameter, y is by name parameter

=== Conditionals, Def/Val

Conditionals are expressions, not statements

[source, scala]
----
val positive = if(x>=0) true else false

def loop = loop

def x = loop // OK, will hang if used

val y = loop // will hang right here
----

=== Blocks (1)

[source, scala]
----
val r = {

  val r = 3 + 3 // <1>

  r * r // <2>
} // 81
----
<2> Definitions inside a block shadow the outside
<1> Last element of a block defines its result

[source, scala]
.Functions in functions
----
def sumSqr(x, y) = {
    def sqr(x) = x * x
    sqr(x) + sqr(y)
}
----

=== Tail recursion (1)

When the last statement of a function is calling itself
kbd:[->] We can reuse the stack frame

[source, scala]
----
// GCD by euclid
@tailrec // no stack overflow, converted to iterative
def gdc(a, b) = {
    if(b==0) a
    else gcd(b, a % b)
}
----

=== Tail recursion (2)

[source, scala]
.Not tail recursive
----
def factorial(x) : Int = if(x==0) 1 else x * factorial(x-1)
// not tail recursive, last action is multiplication
----

[source, scala]
.Tail recursive
----
def factorial(x) : Int = {
   def loop(acc: Int, n: Int) : Int = 
   if(n ==0) acc
   else loop(acc*n, n-1)
   
   loop(1,x)
}
----

=== Higher order functions

Functions that take functions as parameters, or returns them as results

[source, scala]
. Sum from a to b of f(n)
----
def sumF(f: Int => Int, a: Int, b: Int) : Int = {
   if(a>b) 0
   else f(a) + sum(f, a+1, b)
}

def sqr(x) = x * x
def cube(x) = x * x

sumF(sqr, 0, 2) // 5
sumF(cube, 0, 2) // 9 
----